\tikzstyle{block} = [draw,fill=blue!20,minimum size=2em]
% diameter of semicircle used to indicate that two lines are not connected
\tikzstyle{branch}=[fill,shape=circle,minimum size=3pt,inner sep=0pt]

\chapter{Описание комбинационных устройств на VHDL}

\emph{Последовательные и параллельные операторы. Комбинационные логические элементы и их описание на языке VHDL. Операторы выборочного и условного назначения сигналов. Оператор процесса. Запуск процесса и список чувствительности. Операторы IF и CASE. Правила кодирования комбинационных логических устройств на VHDL.}

\section{Параллельное назначение сигналов в VHDL}

В общем случае цифровые устройства можно разделить на комбинационные и последовательные. Комбинационная цепь не имеет памяти, и значения на ее выходах в каждый момент времени зависят только от значений на ее входах.  Последовательная цепь, напротив, имеет память (или внутреннее состояние), и значения на ее выходах зависят как от входных сигналов, так и от внутреннего состояния, т.е. от предыстории функционирования цепи. Операторы параллельного назначения сигналов описывают комбинационные цепи.

\subsection{Простое назначение сигналов}
\begin{lstlisting}
status <= '1';
even <= (p1 and p2) or (p3 and p4);

arith_result <= a + b + c - 1;
\end{lstlisting}
Последнее выражение может быть изображено в виде следующей схемы:

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\tikzstyle{arith_op} = [draw, fill=blue!20, circle, minimum size=2em]

% inputs
\node at (0,3) (input_a) {\texttt{a}};
\node at (0,2) (input_b) {\texttt{b}};
\node at (1,1) (input_c) {\texttt{c}};
\node at (2,0) (input_1) {\texttt{1}};

% operations
\node[arith_op] at (1,2) (block_plus_1) {$+$};
\node[arith_op] at (2,1) (block_plus_2) {$+$};
\node[arith_op] at (3,0) (block_minus) {$-$};

% connections
\draw[->] (input_a) -- (1,3) -- node {} (block_plus_1);
\draw[->] (input_b) -- node {} (block_plus_1);
\draw[->] (block_plus_1) -- (2,2) -- node {} (block_plus_2);
\draw[->] (input_c) -- node {} (block_plus_2);
\draw[->] (block_plus_2) -- (3,1) -- node {} (block_minus);
\draw[->] (input_1) -- node {} (block_minus);
\draw[->] (block_minus) -- (4,0);
\end{tikzpicture}
\caption{Неоптимизированная комбинационная схема.}
\label{comb_circuit_noopt}
\end{figure}

\exsect{Упражнение.} Предположим, что задержки сумматора и блока, вычисляющего разность входных сигналов, одинаковы и равны $\delta$, предположим, что других задержек нет (например, мы не учитываем задержки в проводниках хотя они порой очень существенны). Тогда изменение входного сигнала a отразится на выходном сигнале \lstinline?arith_result? только через $3 \delta$, ведь сигнал должен пройти через три блока, каждый из которых вносит задержку $\delta$. С другой стороны изменение входного сигнала c отразится на выходном сигнале \lstinline?arith_result? только через $2 \delta$. Т.е. схема еще и несимметричная. Можно ли оптимизировать схему, чтобы временная задержка стала меньше, и схема стала симметричной? (Ответ приведен далее, но все же подумайте, попробуйте переставить блоки.)

\exsect{Ответ.} Воспользуемся коммутативностью и ассоциативностью сложения: 
\[
a + b + c - 1 = (a + b) + (c - 1).
\]

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\tikzstyle{arith_op} = [draw, fill=blue!20, circle, minimum size=2em]

% inputs
\node at (0,4) (input_a) {\texttt{a}};
\node at (0,3) (input_b) {\texttt{b}};
\node at (0,1) (input_c) {\texttt{c}};
\node at (0,0) (input_1) {\texttt{1}};

% operations
\node[arith_op] at (1,3) (block_plus_1) {$+$};
\node[arith_op] at (1,1) (block_plus_2) {$+$};
\node[arith_op] at (2,2) (block_minus) {$-$};

% connections
\draw[->] (input_a) -- (1,4) -- node {} (block_plus_1);
\draw[->] (input_b) -- node {} (block_plus_1);
\draw[->] (input_c) -- node {} (block_plus_2);
\draw[->] (input_1) -- (1,0) -- node {} (block_plus_2);
\draw[->] (block_plus_1) -- (2,3) -- node {} (block_minus);
\draw[->] (block_plus_2) -- (2,1) -- node {} (block_minus);
\draw[->] (block_minus) -- (3,2);
\end{tikzpicture}
\caption{Оптимизированная комбинационная схема.}
\label{comb_circuit_opt}
\end{figure}

При создании комбинационных схем \textbf{нельзя} назначать сигналы с обратной связью. С синтаксической точки зрения, следующие выражения корректны, они даже могут быть использованы в определенном контексте. Но их нельзя использовать непосредственно в архитектурном теле.

\begin{lstlisting}
architecture wrong_arch of wrong_entity is
begin
    -- внутреннее состояние:
    q <= (q and (not  en)) or (d and en);

    -- осцилляции q при en = '0':
    q <= (not q and (not en)) or (d and en);
    ...
end wrong_arch
\end{lstlisting}

С другой стороны, следующий код корректен.

\begin{lstlisting}
architecture right_arch of right_entity is
    signal q : std_logic_vector(3 downto 0);
begin
    q <= ('0' & q(3 downto 1)) and d;
    ...
    end right_arch;
\end{lstlisting}

Этот код – более компактная векторная запись следующего кода.

\begin{lstlisting}
architecture right_arch of right_entity is
    signal q : std_logic_vector(3 downto 0);
begin
    q(3) <= '0'  and d(3);
    q(2) <= q(3) and d(2);
    q(1) <= q(2) and d(1);
    q(0) <= q(1) and d(0);
    ...
end right_arch;
\end{lstlisting}

\subsection{Оператор условного назначения сигнала WHEN}
Это параллельный оператор, реализующий выбор одного из возможных вариантов в зависимости от некоторых управляющих сигналов. В общем виде его можно записать следующим образом:

\begin{lstlisting}
 сигнал <= выражение_1     when условие_1     else 
          выражение_2     when условие_2     else 
          ...
          выражение_(n-1) when условие_(n-1) else 
          выражение_n;
\end{lstlisting}

\exsect{Пример 1.} Восьмибитовый мультиплексор 4-в-1.
Рассмотрим комбинационную схему, описываемую таблицей истинности:
\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
input       & output \\ \hline
s           & x      \\ \hline
\texttt{00} & a      \\
\texttt{01} & b      \\
\texttt{10} & c      \\
\texttt{11} & d      \\
\hline
\end{tabular}
\end{table}

VHDL код, реализующий эту схему такой:
\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;

entity mux4 is
    port(
        a, b, c, d : in std_logic_vector(7 downto 0);
        s : in  std_logic_vector(1 downto 0);
        x : out std_logic_vector(7 downto 0)
    );
end mux4;

architecture cond_arch of mux4 is
begin
    x <= a when (s = "00") else
         b when (s = "01") else
         c when (s = "10") else
         d;
end cond_arch;
\end{lstlisting}

Сигнал \lstinline?x? – это выходной информационный сигнал; \lstinline?a?, \lstinline?b?, \lstinline?c?, \lstinline?d? – входные информационные сигналы, а \lstinline?s? – это сигнал управления, на основании которого осуществляется выбор одного из вариантов. 
Рассмотрим еще пару примеров.

\exsect{Пример 2.} Бинарный дешифратор.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
input       & output        \\ \hline
s           & x             \\ \hline
\texttt{00} & \texttt{0001} \\
\texttt{01} & \texttt{0010} \\
\texttt{10} & \texttt{0100} \\
\texttt{11} & \texttt{1000} \\
\hline
\end{tabular}
\end{table}

\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;

entity decoder4 is
    port(
        s : in  std_logic_vector(1 downto 0);
        x : out std_logic_vector(3 downto 0)
    );
end decoder4;

architecture cond_arch of decoder4 is
begin
    x <= "0001" when (s = "00") else
         "0010" when (s = "01") else
         "0100" when (s = "10") else
         "1000";
end cond_arch;
\end{lstlisting}

\exsect{Пример 3.} Шифратор приоритета.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
input               & \multicolumn{2}{c|}{output} \\ \hline
r                   & code        & active         \\ \hline
\texttt{1{-}{-}{-}} & \texttt{11} & \texttt{1}     \\
\texttt{01{-}{-}}   & \texttt{10} & \texttt{1}     \\
\texttt{001-}       & \texttt{01} & \texttt{1}     \\
\texttt{0001}       & \texttt{00} & \texttt{1}     \\
\texttt{0000}       & \texttt{00} & \texttt{0}     \\
\hline
\end{tabular}
\end{table}

\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;

entity prio_encoder42 is
    port(
        r      : in  std_logic_vector(3 downto 0);
        code   : out std_logic_vector(1 downto 0);
        active : out std_logic
    );
end prio_encoder42;

architecture cond_arch of prio_encoder42 is
begin
    code <= "11" when (r(3) = '1') else
            "10" when (r(2) = '1') else
            "01" when (r(1) = '1') else
            "00";
    active <= r(3) or r(2) or r(1) or r(0);
end cond_arch;
\end{lstlisting}

Здесь выходной сигнал \lstinline?code? определяет, на какой из линий \lstinline?r(i)? присутствует логическая единица. Причем линия \lstinline?r(3)? имеет \textbf{приоритет} – если на ней будет \lstinline?'1'?, то \lstinline?code = "11"? вне зависимости от других линий. 

Поговорим о том, как реализуется оператор условного назначения сигнала в железе. Семантика оператора условного назначения сигнала подразумевает создание приоритетной схемы, т.е. условия, стоящие выше имеют больший приоритет. При синтезе этого оператора реализуются три схемы:
\begin{itemize}
\item схема, вычисляющая возможные значения выходного сигнала,
\item схема, вычисляющая условия,
\item схема определения приоритета.
\end{itemize}
Чтобы лучше разобраться, что такое схема приоритета введем понятие абстрактного мультиплексора 2-в-1.

Здесь \texttt{i1}, \texttt{i2}, \texttt{o} – $n$-битные шины, а сигнал \texttt{sel} однобитный. В зависимости от него на выход \texttt{o} идет либо \texttt{i1}, либо \texttt{i0}.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
% inputs
\node at (0,2) (input_i1) {\texttt{i1}};
\node at (0,1) (input_i0) {\texttt{i0}};
\node at (0,0) (input_sel) {\texttt{sel}};

% mux
\draw [-,fill=blue!20](1,0.5) -- (1.5,1) -- (1.5,2) -- (1,2.5) -- cycle;

\node[right] at (1,2) (true) {\texttt{T}};
\node[right] at (1,1) (false) {\texttt{F}};

\path[->] (input_i1) edge node [font=\tiny] {/} node [above] {$n$} (true);
\path[->] (input_i0) edge node [font=\tiny] {/} node [above] {$n$} (false);

\path[->] (1.5,1.5) edge node [font=\tiny] {/} node [above] {$n$} (2.5,1.5);
\node[right] at (2.5,1.5) (true) {\texttt{o}};

\draw[->] (input_sel) -- (1.25,0) -- (1.25,0.75);
\end{tikzpicture}
\caption{Символ абстрактного мультиплексора 2-в-1.}
\label{abstract_mux_symb}
\end{figure}

Когда мы пишем на VHDL выражение:

\begin{lstlisting}
signal_name <= value_expr_1 when boolean_expr_1 else 
               value_expr_2;
\end{lstlisting}

реализуется следующая схема с мультиплексором:

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\tikzstyle{expr} = [draw, fill=yellow!20, dotted, rectangle, minimum size=2em]

% inputs
\node[expr] at (-1,2) (input_i1) {\texttt{value\_expr\_1}};
\node[expr] at (-1,1) (input_i0) {\texttt{value\_expr\_2}};
\node[expr] at (-1,0) (input_sel) {\texttt{boolean\_expr\_1}};

% mux
\draw [-,fill=blue!20](1,0.5) -- (1.5,1) -- (1.5,2) -- (1,2.5) -- cycle;

\node[right] at (1,2) (true) {\texttt{T}};
\node[right] at (1,1) (false) {\texttt{F}};

\draw[->] (input_i1) -- (true);
\draw[->] (input_i0) -- (false);

\draw[->] (1.5,1.5) -- (2.5,1.5);
\node[right] at (2.5,1.5) (true) {\texttt{sig}};

\draw[->] (input_sel) -- (1.25,0) -- (1.25,0.75);
\end{tikzpicture}
\caption{Схема с мультиплексором 2-в-1.}
\label{mux_fig_1}
\end{figure}

Каждый следующий уровень ветвления оператора условного назначения сигнала добавляет еще одну ступень в иерархию вместе с еще одним мультиплексором.

\begin{lstlisting}
signal_name <= value_expr_1 when boolean_expr_1 else 
               value_expr_2 when boolean_expr_2 else 
               value_expr_3;
\end{lstlisting}

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\tikzstyle{expr} = [draw, fill=yellow!20, dotted, rectangle, minimum size=2em]

\begin{scope}
    % inputs
    \node[expr] at (-1,2) (input_i1) {\texttt{value\_expr\_1}};
    \node[expr,fill=red!20] at (-1,1) (input_rem) {\texttt{remaining\_part}};
    \node[expr] at (-1,0) (input_sel) {\texttt{boolean\_expr\_1}};

    % mux
    \draw [-,fill=blue!20](1,0.5) -- (1.5,1) -- (1.5,2) -- (1,2.5) -- cycle;

    \node[right] at (1,2) (true) {\texttt{T}};
    \node[right] at (1,1) (false) {\texttt{F}};
    
    \draw[->] (input_i1) -- (true);
    \draw[->] (input_rem) -- (false);

    \draw[->] (1.5,1.5) -- (2,1.5);
    \node[right] at (2,1.5) (true) {\texttt{sig}};

    \draw[->] (input_sel) -- (1.25,0) -- (1.25,0.75);
\end{scope}

\begin{scope}[xshift=7cm]
    % inputs
    \node[expr] at (-2.5,2) (input_i1) {\texttt{value\_expr\_1}};
    \node[expr] at (-2.5,1) (input_i2) {\texttt{value\_expr\_2}};
    \node[expr] at (-2.5,0) (input_i3) {\texttt{value\_expr\_3}};
    \node[expr] at (-2.5,-1) (input_sel2) {\texttt{boolean\_expr\_2}};
    \node[expr] at (-2.5,-2) (input_sel1) {\texttt{boolean\_expr\_1}};

    % mux
    \draw [-,fill=blue!20](1,0.5) -- (1.5,1) -- (1.5,2) -- (1,2.5) -- cycle;
    \draw [-,fill=blue!20](-0.5,-0.5) -- (0,0) -- (0,1) -- (-0.5,1.5) -- cycle;

    \node[right] at (1,2) (true1) {\texttt{T}};
    \node[right] at (1,1) (false1) {\texttt{F}};
    
    \node[right] at (-0.5,1) (true2) {\texttt{T}};
    \node[right] at (-0.5,0) (false2) {\texttt{F}};
    
    \draw[->] (input_i1) -- (true1);
    
    \draw[->] (0,0.5) -- (0.5,0.5) -- (0.5,1) -- (false1);
    
    \draw[->] (input_i2) -- (true2);
    \draw[->] (input_i3) -- (false2);

    \draw[->] (1.5,1.5) -- (2,1.5);
    \node[right] at (2,1.5) (true1) {\texttt{sig}};

    \draw[->] (input_sel2) -- (-0.25,-1) -- (-0.25,-0.25);
    \draw[->] (input_sel1) -- (1.25,-2) -- (1.25,0.75);
\end{scope}
\end{tikzpicture}
\caption{Схема с мультиплексорами 2-в-1.}
\label{mux_fig_1}
\end{figure}

\subsection{Оператор выборочного назначения сигнала WITH ... SELECT}

Это параллельный оператор, также реализующий выбор одного из возможных вариантов в зависимости от некоторых управляющих сигналов. Во многом он похож на оператор условного назначения, но есть и отличия. Записать в общем виде его можно так:

\begin{lstlisting}[mathescape]
with задающее$\_$выражение select
    сигнал <=
        выражение_1 when выбор_1,
        выражение_2 when выбор_2,
        выражение_3 when выбор_3,
        ...
        выражение_$n$ when выбор_$n$;
\end{lstlisting}

Обратите внимание на использование \emph{запятых} после каждого выборочного значения (\lstinline[mathescape]?выбор_$i$?) и на точку с запятой в конце.

Выборочные значения (\lstinline[mathescape]?выбор_$i$?) должны быть \textbf{взаимно исключающими} (значения не должны перекрываться или повторяться) и \textbf{полными} (все значения должны быть перечислены). Для обеспечения полноты выборочных значений рекомендуется использовать \lstinline?others?. Заметим, что выборочные значения~-- это именно значения, а не условия.

Примеры из предыдущего параграфа можно переписать с использование оператора выборочного назначения сигнала.

\exsect{Пример 1.} Мультиплексор 4-в-1.

\begin{lstlisting}
architecture sel_arch of mux4 is
begin
    with s select
        x <= a when "00",
             b when "01",
             c when "10",
             d when others;
end sel_arch;
\end{lstlisting}

\exsect{Пример 2.} Бинарный дешифратор.

\begin{lstlisting}
architecture sel_arch of decoder4 is
begin
    with sel select
        x <= "0001" when "00",
             "0010" when "01",
             "0100" when "10",
             "1000" when others;
end sel_arch;
\end{lstlisting}

\exsect{Пример 3.} Шифратор приоритета.

\begin{lstlisting}
architecture sel_arch of prio_encoder42 is
begin
    with r select
        code <= "11" when "1000" | "1001" | "1010" |
                          "1011" | "1100" | "1101" |
                          "1110" | "1111",
                "10" when "0100" | "0101" | "0110" |
                          "0111",
                "01" when "0010" | "0011",
                "00" when others;
        active <= r(3) or r(2) or r(1) or r(0);
end sel_arch;
\end{lstlisting}

В последнем примере вертикальной чертой \lstinline?"|"? идет компактное перечисление вариантов, которым соответствует один выходной код.

При синтезе оператора выборочного назначения сигнала реализуется равноправный абстрактный мультиплексор $k$-в-1.

% TODO. Добавить картинку здесь.

В данной схеме \textbf{нет приоритета} при продвижении сигнала с входа на выход схемы. Также можно сказать, что схема получается симметричная с одинаковыми задержками на всех входных линиях.

Проще всего сравнить операторы выборочного и условного назначения сигналов на примере мультиплексора 4-в-1.

При использовании оператора условного назначения будет реализована следующая схема:

% TODO. Добавить картинку здесь.

Видно, что схема несимметричная, с различными задержками по входным сигналам. Но при этом сигнал \texttt{A} имеет приоритет над остальными.

При использовании оператора выборочного назначения сигнала реализуется следующая схема:

% TODO. Добавить картинку здесь.

Здесь схема симметричная, задержки по входным сигналам приблизительно одинаковые. Все сигналы имеют одинаковый приоритет.

У обеих схем \emph{логика работы} и \emph{таблицы истинности} \textbf{одинаковые}, при этом схемные реализации разные. При работе с языком VHDL вы всегда должны пытаться мыслить на уровне логических элементов и схем, чтобы получать эффективные реализации, ведь по сути VHDL – это не более чем удобный инструмент для описания таких объектов. 

\section{Последовательное назначение сигналов в VHDL}

В языке VHDL есть средство для описания последовательных алгоритмов с помощью, так называемых, \emph{последовательных операторов}. Эти операторы должны располагаться внутри специальной конструкции VHDL, называемой \textbf{оператор процесса}. Главной целью введения последовательных операторов в язык VHDL было описание абстрактного \emph{поведения} цифровых цепей (на более высоком уровне абстракции~-- \emph{поведенческом} (\emph{behavioural})). В отличие от операторов параллельного назначения сигналов, последовательные операторы не всегда имеют однозначное соответствие в железе. Часто даже они не могут быть синтезированы вовсе. Поэтому для описания схем с помощью процессов и последовательных операторов необходимо придерживаться четких шаблонов, которые однозначно синтезируются. Рассмотрением этих шаблонов мы и займемся. Пусть вас не пугает слово "<шаблон">: несмотря на то, что определенные компоненты должны описываться по четкой схеме, у вас останется огромное пространство для творчества при определении взаимодействия этих компонентов. 

\subsection{Оператор процесса PROCESS}

Оператор процесса имеет следующий синтаксис:

\begin{lstlisting}[mathescape]
process ( список$\_$чувствительности )
    объявления;
begin
    последовательные$\_$операторы;
    последовательные$\_$операторы;
    ...
end process;
\end{lstlisting}

В подразделе объявлений оператора процесса могут быть объявлены подпрограммы, типы, подтипы, константы, переменные (только в подразделе объявлений оператора процесса), атрибуты, файлы и др. Сигналы в подразделе объявлений оператора процесса объявлены быть \textbf{не могут}.

Сам оператор процесса является \textbf{параллельным оператором}. Если в архитектурном теле разместить несколько процессов, то они будут выполняться параллельно. Но внутри каждого процесса находятся операторы, выполняемые последовательно, т.е. один за другим. Список чувствительности – это список запускающих процесс сигналов. Когда один из сигналов, указанных в списке чувствительности, меняет свое значение, процесс запускается, и последовательные операторы выполняются до конца процесса. После этого процесс приостанавливает свою работу до тех пор, пока опять какой-нибудь сигнал из списка чувствительности не изменит свое значение. Таким образом, процесс может находиться в одном из двух состояний: запущенном и приостановленном. \textbf{Для комбинационной схемы \emph{все входы} должны быть в списке чувствительности.} 

\begin{lstlisting}
signal a, b, c, y: std_logic;
...
process (a, b, c) -- правильно
begin
    y <= a and b or c;
end process;
...
process (a)       -- неправильно
begin
    y <= a and b or c;
end process;
\end{lstlisting}

Внутри процесса сигналу можно присвоить значение несколько раз. При этом значение сигнала не изменится до выхода из процесса, а после выхода станет равным последнему присвоенному значению. Получается, что следующие записи просто эквивалентны.

\begin{lstlisting}
process (a, b, c, d)
begin
	y <= a or c;
	y <= a and b;
	y <= c and d;
end process;
\end{lstlisting}

\begin{lstlisting}
process (a, b, c, d)
begin
	y <= c and d;
end process;
\end{lstlisting}

Очень важно понимать, что последнее значение присваивается сигналу не сразу, а в конце процесса. Промежуточные значения сигнала не доступны. В этом отличие сигнала от \emph{переменной}.

\begin{lstlisting}
architecture arch of main is
    signal y: std_logic;
begin
    process (a, b, c, d)
    begin
        y <= a or c;
        -- Здесь, после оператора присвоения, сигнал y 
        -- не равен a or c.
        -- Здесь могут идти последовательные операторы, 
        -- которые не используют промежуточное значение
        -- сигнала y.
        z <= y;
        -- Здесь сигналу z не присваивается значение  
        -- a or c, ему присваивается значение c and d.
        y <= a and b;
        y <= c and d;
    end process;
    -- Зато здесь, вне тела процесса, y всегда равен c and d
end arch;
\end{lstlisting}

\exsect{Замечание.} Синтезатор XST достаточно умный, чтобы не реализовать в этом конкретном простом примере схему с памятью (ведь сигнала y нет в списке чувствительности процесса), но на синтезатор рекомендуется полагаться не всегда.

На самом деле, с оператором процесса вы уже сталкивались.

\exsect{Вопрос.} Где?

\exsect{Ответ.} Правильно, при описании testbench. Там был процесс stim\_proc, задающий значения входных сигналов для тестируемой схемы.

\exsect{Вопрос} Чего не было в процессе stim\_proc?

\exsect{Ответ.} Там не было списка чувствительности. Но зато там были операторы \lstinline?wait?.
