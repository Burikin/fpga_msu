\chapter{Последовательные логические элементы}

\emph{Понятие триггера. Статическая и динамическая синхронизация. Сложные последовательные элементы: регистры, счетчики, сдвиговые регистры. Описание последовательных элементов на VHDL. Принцип построения синхронных схем.}

\section{Введение}

Начинаем рассмотрение последовательных логических элементов: триггеров, регистров, счетчиков и т.д. Все эти элементы характерны тем, что имеют \emph{состояния} и способны переходить из одного состояния в другое под действием внешних сигналов. Мы будем работать с элементами, управляемыми \emph{тактовым сигналом}, причем переходить из одного состояния в другое (или по-другому переключаться) они могут только в узкой окрестности изменения такого сигнала, называемой \emph{фронтом} сигнала. Различают передний и задние фронты сигнала. Существуют последовательные элементы, переключающиеся по одному фронту (SDR элементы), а есть элементы, работающие по обоим фронтам (DDR элементы). Пример~-- DDR память. 

Зачем нужны эти такты? Такты можно легко считать, измеряя тем самым \emph{длительность} выполнения некой операции. Эта величина может быть как больше, так и меньше периода тактового сигнала $Т$, но даже если она и меньше $Т$, то мы сможем получить результат ее выполнения только на следующем фронте. В первом приближении такт~-- это \emph{минимальный квант} времени в мире синхронных цифровых схем.

Необходимость введения такого кванта времени была обусловлена зависимостью времени выполнения комбинационной схемы от внешних факторов, прежде всего~-- температуры и напряжения. Если в схеме несколько путей распространения сигналов, и рано или поздно они сходятся на очередном элементе с несколькими входами, то надо быть уверенными, что относящиеся к одному событию сигналы пришли к общему элементу одновременно. С использованием только комбинационной логики сделать это крайне трудно, т.к. задержки на комбинационных путях, хотя их и можно рассчитать, зависят от внешних факторов.

Для получения стабильного результата необходимо, чтобы входные сигналы комбинационного элемента не менялись, пока не завершаться все переходные процессы в элементе, т.е. эти данные должны храниться в какой-то памяти, назовем ее триггер. Выходные данные так же должны где-то зафиксироваться, чтобы их можно было передать следующей схеме. При этом, время установления выходных данных определяет частоту работы данной схемы. Подобная парадигма позволяет формировать некоторые логические блоки, которые могут работать независимо друг от друга, т.к. выходные триггеры одной схемы могут быть входными у другой.

\section{Триггеры}

Особенностью последовательных логических элементов является зависимость выходного сигнала не только от действующих в настоящий момент на входе логических переменных, но и от тех значений переменных, которые действовали на входе в предыдущие моменты времени. Для выполнения этого условия значения переменных должны быть запомнены логическим устройством. Функцию запоминания значений логических переменных в цифровых системах выполняют так называемые триггеры.

\subsection{Асинхронный RS-триггер}

Асинхронный RS-триггер имеет два входа $S$(et)~-- установка и $R$(eset)~-- сброс и два выхода прямой~-- $Q$ и инверсный~-- $\tilde Q$. Триггер переходит из текущего состояния $X$ на выходе к состоянию $0$, при подаче на вход $S$ нуля и на вход $R$ единицы, а при поступлении на вход $S$ единицы и на вход $R$ нуля триггер переходит к состоянию $1$. При нулевых значениях, когда $S=R=0$ триггер должен сохранять старое значение. Комбинация сигналов $S=R=1$ не определена.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок RS-триггера}};
\end{tikzpicture}
\caption{Обозначение и схема асинхронного RS-триггера}
\label{RS_trigger_arch}
\end{figure}

Приведенному описанию соответствует схема, приведенная на рисунке. RS триггер можно строить как на элементах "<2ИЛИ-НЕ">, так и на элементах "<2И-НЕ">. В первом случае получается триггер с прямыми входами (т.е. с единичным активным уровнем).

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
$S$        & $R$        & $Q_{n+1}$   \\ \hline
\texttt{0} & \texttt{0} & $Q_n$       \\
\texttt{0} & \texttt{1} & \texttt{0}  \\
\texttt{1} & \texttt{0} & \texttt{1}  \\
\texttt{1} & \texttt{1} & \texttt{?}  \\
\hline
\end{tabular}
\end{table}

Во втором случае триггер будет управляться нулевым активным уровнем сигналов, и будет называться RS триггером с инверсными входами.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
$\tilde S$ & $\tilde R$ & $Q_{n+1}$   \\ \hline
\texttt{0} & \texttt{0} & \texttt{?}  \\
\texttt{0} & \texttt{1} & \texttt{1}  \\
\texttt{1} & \texttt{0} & \texttt{0}  \\
\texttt{1} & \texttt{1} & $Q_n$       \\
\hline
\end{tabular}
\end{table}

\subsection{RS триггер со статической синхронизацией}

К RS триггеру можно добавить сигнал синхронизации $С$. Когда $C=1$, то триггер может переключиться, если $C=0$, то не может. Такой триггер будет называться синхронным RS триггером со статической синхронизацией. Значение слова "<статической"> вам будет ясно чуть позже.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок RS-триггера с сигналом синхронизации}};
\end{tikzpicture}
\caption{Обозначение и схема асинхронного RS-триггера с сигналом синхронизации}
\label{RS_trigger_C_arch}
\end{figure}

Далее можно добавить асинхронные входы установки и сброса триггера.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок RS-триггера с сигналом синхронизации}};
\end{tikzpicture}
\caption{Обозначение и схема асинхронного RS-триггера с сигналом синхронизации и асинхронными сигналами установки и сброса}
\label{RS_trigger_C_ARS_arch}
\end{figure}

Асинхронными они называются потому, что подаются напрямую на ячейку памяти, и сигнал синхронизации никак не может на них повлиять.

\subsection{D триггер (D защёлка)}

Вместо двух входов $R$ и $S$ у триггера может быть только один вход $D$ (Data).

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок RS-триггера с сигналом синхронизации}};
\end{tikzpicture}
\caption{Обозначение и схема асинхронного D-триггера}
\label{D_trigger_arch}
\end{figure}

Идея заключается в том, что требуется исключить запрещенное значение входов, т.е. подавать на RS-триггер только разрешенные комбинации. Для этого мы на вход $S$ подаём сигнал $D$, а на вход $R$ подаём $\tilde D$. Таким образом мы исключаем запрещенное значение на входах. Для того, чтобы триггер мог хранить свое значение, вводится сигнал \emph{статической} синхронизации $C$. Рассмотренная схема является \emph{защёлкой} (latch). На VHDL она реализуется следующим образом:

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Latch is
    port ( C : in  STD_LOGIC;
           D : in  STD_LOGIC;
           Q : out STD_LOGIC);
end Latch;

architecture Behavioral of Latch is
    signal q_tmp : std_logic := '0';
begin
    latch_process: process (C, D)
    begin
        if (C = '1') then
            q_tmp <= D;
        end if;
    end process;
    Q <= q_tmp;
end Behavioral;
\end{lstlisting}
\end{Code}

Может показаться, что код триггера~-- защелки очень похож на код, описывающий комбинационный элемент. Однако, видно, что сигнал \lstinline?q_tmp? будет назначаться не при каждом вызове процесса \lstinline?latch_process?, потому дерево условий \lstinline?if? тут неполное. Процесс будет запускаться при любом изменении сигналов из списка чувствительности \lstinline?С? и \lstinline?D?. Представим, что \lstinline?D? меняется в тот момент, когда \lstinline?С = 0?. Тогда процесс запуститься, но условие \lstinline?С = 1? не будет выполнено. В этом случае сигнал \lstinline?q_tmp? в соответствии с семантикой языка VHDL сохранит свое предыдущее значение, и получиться аппаратный элемент триггер-защёлка. 

Триггер-защёлка~-- это асинхронный элемент памяти, и в проектах на FPGA его использовать настоятельно не рекомендуется (хотя САПР это позволяет). Ниже в этой лекции при обсуждении методологии проектирования синхронных схем будет ясно почему.

\subsection{D триггер с динамической синхронизацией}

Рассмотренные выше триггеры имеют статическую синхронизацию. Это означает, что они управляются уровнем сигнала синхронизации. Т.е., этот сигнал выступает в виде разрешения на изменения. Промежуток времени, когда $C=1$ может быть довольно значителен. В течение этого времени триггер просто передает на выход значение входного сигнала. Если вход триггера изменится, то изменится и выход. Обычно в цифровых системах значение триггера меняется только один раз за период тактового сигнала, и поэтому вход триггера должен оставаться неизменным в течение всего времени пока $C=1$, а это накладывает сильные ограничения на входной сигнал и сильно усложняет проектирование схем.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Временная форма}};
\end{tikzpicture}
\caption{Временная форма сигналов для D-триггеров со статической и динамической синхронизацией}
\label{D_trigger_waveform}
\end{figure}

Ситуацию можно сильно упростить, если сделать триггер нечувствительным к изменению входного сигнала даже во время действия высокого уровня синхросигнала и заставить его переключаться в течение намного меньшего промежутка времени вокруг так называемого фронта синхроимпульса. Такие триггеры есть, и называются они триггерами с динамической синхронизацией. Говорят, что они чувствительны не к уровню (как триггеры со статической синхронизацией), а к изменению или фронту синхросигнала. Если изменение состояния триггера происходит по переднему фронту синхросигнала, т.е. по изменению сигнала с 0 на 1, то говорят, что он снабжен прямым динамическим входом. Если же изменение состояния триггера происходит по заднему фронту, т.е. по изменению с 1 на 0, то считают, что он имеет инверсный динамический вход.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок D-триггера}};
\end{tikzpicture}
\caption{Архитектура D-триггера с динамической синхронизацией}
\label{D_trigger_arch}
\end{figure}

Построить триггер с динамической синхронизацией довольно несложно. Достаточно соединить последовательно две D-защелки (первую назовем master-защелкой, вторую~-- slave-защелкой). Пусть $CLK$~-- сигнал синхронизации (синхросигнал). Когда $CLK=0$, master-триггер пропускает все, что подается на его вход, но slave-триггер помнит свое состояние, и в итоге на выходе сигнал соответственно не изменяется. Когда $CLK$ становится равным 1, master-триггер закрывается, запоминая последнее значение входного сигнала, а slave-триггер открывается и пропускает значение с master-триггера на выход. В каждый момент времени, когда сигнал $CLK$ постоянен какой-то из триггеров поддерживает постоянное значение на своем выходе, а, следовательно, и на выходе всей схемы. Только в момент перехода сигнала $CLK$ из 0 в 1 происходит изменение состояния триггеров.

Рассмотренный D триггер с динамической синхронизацией сохраняет значение логической переменной, действующей на информационном входе $D$ в момент каждого переднего фронта синхросигнала. Иногда требуется, чтобы триггер изменял свое значение не по каждому такому фронту, а только в определенные промежутки времени. Для этого требуется введение дополнительного управляющего сигнала, называемого $CE$ (Clock Enable). Он может быть реализовываться через элемент "<И"> входов $CE$ и $С$. Отсюда и название: $CE$~-- Clock Enable~-- Разрешение Тактов. Однако это приводит к внесению дополнительной задержки на синхровход, и такой подход не применяется в ПЛИС. Второй подход заключается в использовании мультиплексора в цепи информационного входа $D$.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок D-триггера}};
\end{tikzpicture}
\caption{Архитектура D-триггера с динамической синхронизацией и разрешением записи}
\label{D_trigger_CE_arch}
\end{figure}

D триггер является базовым триггером для ПЛИС. В дальнейшем, когда мы будем говорить "<D триггер">, мы будем иметь в виду D триггер с динамической синхронизацией и входом разрешения работы $CE$. 

\subsection{Счетный Т триггер}

Последний триггер, который мы рассмотрим, называется счётный Т триггер. По определению если в момент прихода синхроимпульса на входе $Т=1$, то триггер изменяет свое состояние на противоположное. Если $Т=0$ в момент прихода фронта тактового сигнала, триггер сохраняет свое значение.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок D-триггера}};
\end{tikzpicture}
\caption{Архитектура T-триггера с динамической синхронизацией}
\label{T_trigger_arch}
\end{figure}

\subsection{Реализация триггеров на VHDL}

Триггеры внутри ПЛИС реализуются не за счёт логических элементов, как было описано выше, они уже реализованы внутри кристалла. В прошивке указывается то, как они должны быть сконфигурированы (вид сброса, наличие сигнала разрешения на запись и т.п.). Чтобы трассировщик знал какую именно конфигурацию выбрать необходимо определённым образом описывать поведение сигналов. При описании процессов в списке чувствительности должен находится только синхросигнал, т.к. только его изменение должно вызывать процесс, а также асинхронные сигналы, например, сигнал асинхронного сброса. Внутри процесса все сигналы, значения которых сохраняются на триггере, должны находится внутри следующей конструкции:

\begin{Code}
\begin{lstlisting}
if (clk'event and clk = '1') then
    ...
end if;
\end{lstlisting}
\end{Code}

Здесь сигнал \lstinline?clk?~-- синхросигнал.
Приведённый выше код предназначен для случая синхронизации по фронту, если же необходима синхронизация по спаду, то она должна иметь вид:

\begin{Code}
\begin{lstlisting}
if (clk'event and clk = '0') then
    ...
end if;
\end{lstlisting}
\end{Code}

Для краткости можно писать вместо \lstinline?clk'event and clk = '1'? функцию \lstinline?rising_edge(clk)?. Аналогично и для конструкции \lstinline?clk'event and clk = '0'? заменой будет \lstinline?falling_edge(clk)?. В списке чувствительности процесса, в котором должна находится эта конструкция, должен быть объявлен сигнал \lstinline?clk?. Если в схеме используются какие-то асинхронные сигналы, то они тоже должны быть добавлены в список чувствительности.

\subsubsection{Написание testbench для синхронных схем}

Отличительной особенностью синхронных схем является наличие синхронизирующего сигнала. Обычно этот сигнал является внешним для схемы и генерируется внешним кварцевым генератором. Рассмотрим три способа симуляции этого сигнала в testbench.

\begin{Code}
\begin{lstlisting}
library ieee;
use ieee.std_logic_1164.all;

entity main_tb is
end main_tb;

architecture Behavioral of main_tb is
    signal clk_0 : std_logic := '0'; -- Важно присвоить 
                                     -- начальное значение

    signal clk_1 : std_logic := '0'; -- Важно присвоить 
                                     -- начальное значение

    signal clk_2 : std_logic;        -- Не обязательно 
                                     -- присваивать начальное 
                                     -- значение
    
    constant clk_period : time := 10 ns;
    
    signal a : std_logic_vector(2 downto 0) := (others => '0');
begin
    -- Первый способ
    clk_0 <= not clk_0 after clk_period/2;
    
    -- Второй способ
    process
    begin
        wait for clk_period/2;
        clk_1 <= not clk_1;
    end process;
    
    -- Третий способ
    process
    begin
        clk_2 <= '0';
        wait for clk_period/2;
        clk_2 <= '1';
        wait for clk_period/2;
    end process;
    
    -- Пример использования
    a <= (0 => clk_0, 1 => clk_1, 2 => clk_2);
end Behavioral;
\end{lstlisting}
\end{Code}

Все эти способы дают одинаковый результат. Третий способ является наиболее громоздким, но в то же время наиболее гибким. Только таким способом можно симулировать сигнал со скважностью, отличной от 50\% (т.е. случай, когда длительность \lstinline?'1'? не равна длительности \lstinline?'0'?).

\subsubsection{Пример реализации D триггера}

Рассмотрим код, реализующий простой D триггер. На входе у него синхроимпульс \lstinline?clk? и вход данных \lstinline?D?, выход~-- \lstinline?Q?.

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Dtrig is
    port ( clk : in  STD_LOGIC;
           D   : in  STD_LOGIC;
           Q   : out STD_LOGIC);
end Dtrig;

architecture Behavioral of Dtrig is
begin
    process (clk)
    begin
        if (rising_edge(clk)) then
            Q <= D;
        end if;
    end process;
end Behavioral;
\end{lstlisting}
\end{Code}

\subsubsection{Пример реализации D триггера с сигналом разрешения записи}

Модернизируем предыдущий пример, добавив сигнал \lstinline?CE?~-- сигнал разрешения.

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DtrigCE is
    port ( clk : in  STD_LOGIC;
           D   : in  STD_LOGIC;
           CE  : in  STD_LOGIC;
           Q   : out STD_LOGIC);
end DtrigCE;

architecture Behavioral of DtrigCE is
    signal Q_tmp : std_logic := '0';
begin
    process (clk)
    begin
        if (rising_edge(clk)) then
            if (CE = '1') then
                Q_tmp <= D;
            end if;
        end if;
    end process;
    Q <= Q_tmp;
end Behavioral;
\end{lstlisting}
\end{Code}

\subsubsection{Пример реализации D триггера с синхронным сбросом}

Рассмотрим случай сигнала синхронного сброса \lstinline?reset? у обычного D триггера.

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DtrigSReset is
    port ( clk   : in  STD_LOGIC;
           D     : in  STD_LOGIC;
           reset : in  STD_LOGIC;
           Q : out STD_LOGIC);
end DtrigSReset;

architecture Behavioral of DtrigSReset is

begin
    process (clk)
    begin
        if (rising_edge(clk)) then
            if (reset = '1') then
                Q <= '0';
            else
                Q <= D;
            end if;
        end if;
    end process;
end Behavioral;
\end{lstlisting}
\end{Code}

\subsubsection{Пример реализации D триггера с асинхронным сбросом}

Рассмотрим случай сигнала асинхронного сброса reset у обычного D триггера. Для этого сам процесс должен реагировать на изменения сигнала \lstinline?reset?, независимо от состояния линии \lstinline?clk?, поэтому необходимо включить сигнал reset в список чувствительности. Изменения выходного сигнала \lstinline?Q?, связанного со сбросом, должно происходить вне блока 

\begin{Code}
\begin{lstlisting}
if (rising_edge(clk)) then
    ...
end if;
\end{lstlisting}
\end{Code}

Этот блок имеет следующий вид:

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DtrigAReset is
    port ( clk   : in  STD_LOGIC;
           D     : in  STD_LOGIC;
           reset : in  STD_LOGIC;
           Q     : out STD_LOGIC);
end DtrigAReset;

architecture Behavioral of DtrigAReset is

begin
    process (clk, reset)
    begin
        if (reset = '1') then
            Q <= '0';
        elsif (rising_edge(clk)) then
            Q <= D;
        end if;
    end process;
end Behavioral;
\end{lstlisting}
\end{Code}

\subsubsection{Пример реализации T триггера}

Рассмотрим простой счётный триггер. У него есть только один входной сигнал~-- синхроимпульс (clk) и один выходной~-- данные (Q).

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Ttrig is
    port ( clk : in  STD_LOGIC;
           Q   : out STD_LOGIC);
end Ttrig;

architecture Behavioral of Ttrig is
    signal Q_tmp : std_logic := '0';
begin
    process (clk)
    begin
        If (rising_edge(clk)) then
            Q_tmp <= not Q_tmp;
        end if;
    end process;
    Q <= Q_tmp;
end Behavioral;
\end{lstlisting}
\end{Code}

\subsection{Детектор переднего фронта сигнала}

В качества другого примера использования триггеров рассмотрим детектор фронта, т.е. устройство, которое выдаёт импульс, как только происходит перепад входного сигнала из 0 в 1. Входные сигнала элемента: \lstinline?rst_n?~-- сигнал сброса (активен нулем, о чем говорит суффикс \lstinline?_n?), \lstinline?clk?~-- тактовая частота, \lstinline?sig_in?~-- внешний сигнал, \lstinline?tick_out?~-- импульс, который сигнализирует об изменении \lstinline?sig_in? из 0 в 1.

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity rising_edge_detect is
    port ( rst_n    : in  STD_LOGIC;
           clk      : in  STD_LOGIC;
           sig_in   : in  STD_LOGIC;
           tick_out : out STD_LOGIC);
end rising_edge_detect;

architecture rtl of rising_edge_detect is
    signal sig_n    : std_logic;
begin

process (clk,rst_n)
begin
    if rst_n = '0' then
        sig_n    <= '0';
    elsif rising_edge(clk) then
        sig_n    <= not sig_in;
    end if;
end process;

tick_out    <= sig_in and sig_n; 
end rtl;
\end{lstlisting}
\end{Code}

Обратите внимание, входной сигнал \lstinline?sig_in? изменяется без привязки к фронтам тактового сигнала \lstinline?clk?. Внутренний сигнал \lstinline?sig_n? схемы~-- это пропущенное через триггер (а значит задержанное на один такт) отрицание сигнала \lstinline?sig_in?. Далее сигнал \lstinline?tick_out? назначается в помощью параллельного оператора назначения сигнала вне процесса (это комбинационный элемент). Он будет равен 1 только если оба сигнала \lstinline?sig_in? и \lstinline?sig_n? равны 1 одновременно. Это приводит к тому, что длительность сигнала \lstinline?tick_out? всегда будет меньше одного такта. Часто из-за отсутствия прямой связи между входным и тактовым сигналами длительность \lstinline?tick_out? может быть совсем маленькой, что потом приводит к проблемам.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок архитектуры детектора фронтов}};
\end{tikzpicture}
\caption{Архитектура детектора фронтов}
\label{register_arch}
\end{figure}

Важно сделать схему, выдающую стабильный результат с длительностью выходного сигнала ровно 1 такт. Для этого выход схемы достаточно просто пропустить еще через один триггер.

\section{Сложные последовательные элементы}

Перейдём теперь к соединению триггеров между собой. Один триггер может представлять 1 битовое двоичное число. Для представления n-битного числа требуется n битов. На практике мы часто работаем с 8, 16 и 32 битными числами. Если соединить несколько триггеров вместе, то получится регистр. Регистром называется последовательное устройство, предназначенное для записи, хранения и (или) сдвига информации, представленной в виде многоразрядного двоичного кода. Любой N разрядный регистр состоит из N однотипных ячеек~-- разрядных схем. При этом каждая разрядная схема, как любое последовательное устройство, состоит из триггера (элемента памяти) и некоторой комбинационной схемы, преобразующей входные воздействия и состояние триггера в выходные сигналы регистра. Ниже приведена схема регистра (слева) и его условное обозначение (справа).

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок регистра}};
\end{tikzpicture}
\caption{Реализация регистра}
\label{register_arch}
\end{figure}

\subsection{Сдвиговые регистры}

Сдвиговые регистры выполняются на основе триггеров с динамическим синхровходом. Для этого триггеры соединяются последовательно, выходы предыдущих триггеров соединяются со входами последующих. Ниже приведена схема такого элемента, построенного на D-триггерах (слева) и его условное обозначение (справа):

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок сдвигового регистра}};
\end{tikzpicture}
\caption{Реализация сдвигового регистра}
\label{shift_register_arch}
\end{figure}
 
С приходом очередного положительного фронта синхроимпульса C длительностью t0,1, сигнал со входа i-го триггера через время tзд.р. окажется на его выходе и поступит на вход следующего (i+1)-го триггера. Однако на его выход эта информация не перепишется, т.к. длительность активного фронта t0,1 меньше tзд.р.. На этом процесс сдвига данных на один разряд закончится до прихода следующего положительного фронта тактового сигнала. Основные назначения сдвиговых регистров~-- задержка данных, преобразование из параллельного кода в последовательный и обратно.

\subsubsection{Пример реализации сдвигового регистра на VHDL}

Рассмотрим 8-ми разрядный последовательный сдвиговый регистр. Вход данных обозначим как D, синхроимпульс обозначается как раньше clk, а выходной сигнал~-- Q.

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity SReg8 is
    port ( clk : in  STD_LOGIC;
           D   : in  STD_LOGIC;
           Q   : out STD_LOGIC);
end SReg8;

architecture Behavioral of SReg8 is
    signal S : std_logic_vector(7 downto 0) := (others => '0');
begin
    process (clk)
    begin
        if (rising_edge(clk)) then
            S(7 downto 1) <= S(6 downto 0);
            S(0) <= D;
        end if;
    end process;
    Q <= S(7);
end Behavioral;
\end{lstlisting}
\end{Code}

В приведённом примере используется шина S для хранения данных сдвигового регистра. Каждая из линий S представляется в виде отдельного триггера, процесс переноса описывается строчкой: \lstinline?S(7 downto 1) <= S(6 downto 0);? а процесс загрузки новых данных: \lstinline?S(0) <= D;?. Данные выталкиваются наружу из старшего триггера: \lstinline?Q <= S(7);?.

\subsubsection{Пример реализации сдвигового регистра с параллельной загрузкой}

На практике часто необходимо преобразовывать параллельный код в последовательный обратно. Это делается с помощью сдвиговых регистров. Рассмотри преобразование параллельного кода в последовательный. К предыдущему примеру добавятся дополнительные сигналы: \lstinline?Load? (флаг загрузки данных) и \lstinline?LD? (загружаемые данные). Данные \lstinline?LD?~-- это 8-битовое слово в параллельном коде, которое необходимо перевести в последовательный код, а значит выдать в однобитовую выходную линию \lstinline?Q? значение \lstinline?LD? бит за битом за 8 тактов. Здесь мы не используем входной сигнал \lstinline?D?, вместо него сдвиговый регистры будет циклически перезаписывать сам себя.

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity SReg8_ParLoad is
    port ( clk  : in  STD_LOGIC;
           LD   : in  STD_LOGIC_VECTOR (7 downto 0);
           Load : in  STD_LOGIC;
           Q    : out STD_LOGIC);
end SReg8_ParLoad;

architecture Behavioral of SReg8_ParLoad is
    signal S : std_logic_vector(7 downto 0) := (others => '0');
begin
    process (clk)
    begin
        if (rising_edge(clk)) then
            if (Load = '1') then
                S <= LD;
            else
                S(7 downto 0) <= S(6 downto 0) & S(7);
            end if;
        end if;
    end process;
    Q <= S(7);
end Behavioral;
\end{lstlisting}
\end{Code}

\subsection{Счётчики}

Счётчик~-- последовательная схема, которая преобразует поступающие на вход импульсы в параллельный код, эквивалентный количеству пришедших импульсов. Счётчики могут считать импульсы в различных системах отсчёта (двоичный, двоично-десятичный), иметь сигнал разрешения на счёт, возможность параллельной загрузки состояния счётчика, выдача сигнала о переполнении, либо о достижении какого-то значения. Ниже приведена схема самой простой реализации четырёхбитного счётчика.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=latex']
\node at (0,0) {\texttt{Рисунок счётчика на T-триггера + с помощью регистра и "+1"}};
\end{tikzpicture}
\caption{Реализация счетчика}
\label{counter_arch}
\end{figure}
 
Будем считать, что нумерация триггеров идёт от верхнего (0-й) до нижнего (3-й). В начальном состоянии все регистры находятся в 0-м состоянии, при приходе синхроимпульса своё состояние на 1 меняет только 0-й T триггер, так как на остальные поступают только 0. На следующем такте он же меняется обратно в 0, а 1-й~-- в высокое состояние. На следующем такте меняет своё состояние на 1 только 0-й триггер. 2-й триггер не может этого сделать, т.к. зависит от предыдущего состояния 0-го триггера. И так далее до тех пор, пока все они не будут в высоком состоянии. Следующим их состоянием с приходом синхроимпульсом будет 0, так называемое переполнение счётчика. 

\subsubsection{Пример реализация счётчика на VHDL}

Рассмотрим реализацию 4-х битного счётчика, который считает каждый импульс. Входной сигнал - \lstinline?clk? (синхроимпульс), выходной сигнал~-- \lstinline?Q?.

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity Counter4 is
    port ( clk : in  STD_LOGIC;
           Q   : out STD_LOGIC_VECTOR (3 downto 0));
end Counter4;

architecture Behavioral of Counter4 is
    signal counter : std_logic_vector(3 downto 0) 
                     := (others => '0');
begin
    process (clk)
    begin
        if (rising_edge(clk)) then
            counter <= counter + 1;
        end if;
    end process;
    Q <= counter;
end Behavioral;
\end{lstlisting}
\end{Code}

\subsubsection{Пример реализации реверсивного счётчика с параллельной загрузкой}

Помимо прямого счёта, т.е. инкрементального, бывают и реверсивные счётчики, которые считают в обратном направлении. Это может оказаться полезным, когда необходимо отсчитать какое-то количество тактов и выдать сигнал об окончании счёта.

Рассмотрим реверсивный счётчик, который выдаёт сигнал об окончании счёта. В качестве входов у него будет синхроимпульс (\lstinline?clk?), флаг загрузки данных (\lstinline?load?) и шину данных (\lstinline?DL?). Выходной сигнал \lstinline?CR?~-- окончание счёта.

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity RevCounter4 is
    port ( clk  : in  STD_LOGIC;
           load : in  STD_LOGIC;
           DL   : in  STD_LOGIC_VECTOR (3 downto 0);
           CR   : out STD_LOGIC);
end RevCounter4;

architecture Behavioral of RevCounter4 is
    signal counter : std_logic_vector(3 downto 0) 
                     := (others => '1');
begin
    process (clk)
    begin
        if (rising_edge(clk)) then
            if (load = '1') then
                counter <= DL;
            else
                if (counter /= 0) then
                    counter <= counter - 1;
                end if;
            end if;
        end if;
    end process;
    CR <= '1' when counter = 0 else '0';
end Behavioral;
\end{lstlisting}
\end{Code}

\subsubsection{Пример реализации сдвигового регистра с параллельным выходом на VHDL}

Рассмотрим теперь обратное преобразование последовательного кода в параллельный. Пусть на вход D поступают входные данные бит за битом. Мы будем сохранять их в сдвиговым регистре, значение которого будет выдаваться на выходную 8ми битную шину схемы после прихода 8 бит данных. 

\begin{Code}
\begin{lstlisting}
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity SReg8_ParOut is
    port ( clk   : in  STD_LOGIC;
           reset : in  STD_LOGIC;
           en    : in  STD_LOGIC; 
           D     : in  STD_LOGIC;
           Q     : out STD_LOGIC_VECTOR (7 downto 0)
           valid : out STD_LOGIC
);
end SReg8_ParOut;

architecture Behavioral of SReg8_ParOut is
    signal S : std_logic_vector(7 downto 0);
    signal cnt : std_logic_vector(3 downto 0);
begin
    process (clk)
    begin
        if (rising_edge(clk)) then

            if reset = '1' then
                S    <= (others => '0');
            elsif en = '1' then
                
                S(7 downto 1) <= S(6 downto 0);
                S(0) <= D;
            end if;

            if reset = '1' then
                cnt  <= (others => '0'); 
            elsif cnt = "1000" then
                cnt <= "0000" 
            elsif en = '1' then
                
                cnt  <= cnt + 1;
            end if;

        end if;
    end process;
    Q <= S;
    valid <= '1' when cnt = "1000" else '0';

end Behavioral;
\end{lstlisting}
\end{Code}

Возможна реализация различных сдвиговых регистров: с параллельной загрузкой, реверсивные регистры (направление сдвига определяется состоянием одного из входов), частично параллельный регистр (не все триггеры выставляют данные на выходную шину) и т.п. На практике все эти виды регистров полезны для перевода параллельного кода (шины) в последовательный код (линию) и обратно, что используется при передаче данных в таких протоколах как USB, RS232, Ethernet и т.п.

\subsection{Мигание светодиодом}

Реализуйте схему, которая мигала бы светодиодом 1 раз в секунду (0,5 секунды светодиод не горит, 0,5 секунды светодиод горит).

\subsection{Светодиодный сдвиговый регистр}

Реализуйте сдвиговый регистр на светодиодах и переключателях. На плате ZYBO имеется 4 светодиода: LD0~-- LD3. На LD0 должно выводиться значение переключателя SW0. Затем каждую секунду значение LD0 должно переводиться на LD1, значение LD1~-- на LD2, и т.д.

\subsection{Контрольные вопросы}

\begin{enumerate}
\item Схема RS триггера, его таблица истинности и описание поведения отдельных элементов в зависимости от состояний на входах.
\item Получить из RS триггера D триггер.
\item VHDL код D триггера.
\item VHDL код T триггера.
\item Схема простого сдвигового регистра на D триггерах.
\item Схема сдвигового регистра с параллельным выходом.
\item VHDL код сдвигового регистра с параллельной загрузкой.
\item VHDL код сдвигового регистра с параллельной загрузкой и выходной шиной.
\item Схема простого счётчика и описание его поведения (временная диаграмма работы).
\item VHDL код простого счётчика.
\item VHDL код реверсивного счётчика с параллельной загрузкой.
\end{enumerate}

\subsection{Домашнее задание}

\begin{enumerate}
\item Создать детектор спадов.
\item Создать детектор фронтов и спадов.
\item Моделирование. Создать детектор фронта, выходной импульс которого длится: 4 такта, 8 тактов, может быть в пределах от 1 до 16 (задается с помощью входного сигнала шириной 4 бита).
\end{enumerate}
