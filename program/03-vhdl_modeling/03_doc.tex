\chapter{Моделирование схем на языке VHDL}

\emph{Введение в моделирование. Визуальный анализ значений сигналов. Вывод на консоль во время моделирования. Файловый ввод/вывод. Концепция самопроверяющихся testbenches.}

\section{Введение в моделирование}

При разработке серьезных аппаратных проектов значительную роль отводят процессу моделирования. Моделирование - это процесс отладки или верификации, направленный на выявление логических ошибок в работе схемы.\footnote{Можно еще отдельно выделить моделирование, с учетом времянных задержек элементов схемы, направленное на выявление времянных ошибок, но в большинстве реальных слуаев возможно обойтись без него, и этот процесс не будет рассмотрен в данном курсе.} Как правило, проект может быть разбит на \emph{модули}, которые можно верифицировать независимо друг от друга. Этим никогда нельзя пренебрегать, и писать такие unit-тесты на модули - хорошая практика. Второй подход, дополняющий создание unit-тестов, - это верифицировать весь проект (или большую часть проекта) целиком, учитывая взаимодействие между модулями. В этом случае говорят о создании интеграционнного теста.
Независимо от того, какой тест разрабатывается (юнит или интеграционный), первой задачей является определение одного VHDL модуля, внутри которого находится схема для проверки. Для юнит теста, когда верифицируется один VHDL модуль - это задача тривиальная, а для интеграционного теста необходимо создать модуль обертку \emph{wrapper}, внутрь которого поместить все интересные для теста модули. Этот единственный модуль верхнего уровня принято называть Design Under Test или просто DUT. 
Модуль DUT затем вставляется как компонент в специальный VHDL модуль, называемый тестбенч (testbench). Особенностями модуля тестбенч является следующее:
\begin{enumerate}
\item Он не имеет внешних портов ввода/вывода. Тестбенч - это виртуальный стенд тестирования схемы DUT. В тестбенче происходит генерация входных сигналов DUT и анализ выходных.
\item В этом модуле можно и нужно использовать \emph{несинтезируемые} VHDL контрукции. 
\end{enumerate}

\subsection{VHDL конструкции для синтеза и для моделирования}

\subsection{Простейшая testbench и визуальный анализ сигналов}

\section{Хорошая практика моделирования}

Рассмотренный выше подход является минимальной схемой тестирования, способной выявить лишь малую часть ошибок в схеме. Большие проекты, содержащие сотни управляющих сигналов и шин данных невозможно верифицировать с помощью визуального анализа вейформ сигналов. Необходимо использовать другие методы, самый простой из которых - это создание самопроверяющегося тестбенча, когда на схему подаются известные опорные воздействия, а результат работы схемы автоматически сравнивается с известными опорными результатами (golden results). В итоге разработчику просто выводится сообщение о том, прошел тест или нет. Конечно, написание такого тестбенча иногда бывает не легче, чем разработать саму схему, но процесс дебага (debug) никто не отменял, и умение писать качественные тестбенчи является необходимым для современного инженера - разработчика ПЛИС. Прежде чем перейти к описанию, как создавать такие самопроверяющиеся тестбенчи, необходимо рассмотреть вывод тектовой информации на консоль и файловый ввод/вывод. 

\subsection{Вывод на консоль во время симуляции}

В большинстве языков программирования существует стандартный вывод - механизм, обеспечивающий отображение текстовой информации на мониторе во время работы программы. Язык VHDL также предоставляет такую возможность. Но эта возможность не относится к синтезируемому подмножеству языка - текстовый вывод можно осуществлять только из тестбенча во время моделирования разрабатываемой схемы. В качестве консоли будет выступать текстовое окно вывода среды, в которой происходит моделирование, например Vivado. Хотя среда моделирования предоставляет возможность непосредственно наблюдать значения всех сигналов проекта в окне времянных диаграмм, часто бывает полезно выводит и текстовые сообщения. Эта функциональность обеспечивается стандартной библиотекой textio. Для того чтобы воспользоваться ее функциями необходимо добавить выражение

\begin{lstlisting}
use textio.all;
\end{lstlisting}
непосредственно перед каждой архитектурой, использующей вывод на консоль. На самом деле, с помощью этой библиотеки можно также и осуществлять файловый ввод/вывод, но об этом в следующем параграфе. 

Текстовая информация может быть выдана через переменную (\emph{variable}) типа \emph{line}. Вывод на консоль может быть осуществлен только изнутри процесса, где все операторы исполняются последовательно. Для вывода информации в консоль, сначала ее необходимо поместить в переменную типа \emph{line}, а затем вызвать специальную функцию для собственно выдачи. Следующий пример это иллюстрирует.

\begin{lstlisting}[caption=Вывод в консоль, float]
use textio.all;
architecture behavior of check is
begin
  process (x)
    variable s : line;
    variable cnt : integer:=0;
  begin
    if (x='1' and x'last_value='0') then
      cnt:=cnt+1;
      if (cnt>MAX_COUNT) then
        write(s,"Counter overflow - ");
        write(s,cnt);
        writeline(output,s);
      end if;
    end if;
  end process;
end behavior;
\end{lstlisting}


Функция \emph{write()} используется для добавления текстовой информации в конец строковой переменной \emph{s}, которая инициализируется пустой строчкой. Функция \emph{write()} имеет два аргумента, первый - это имя переменной, куда надо добавить данные, второй - это сами данные. В нашем примере сначала в переменную \emph{s} записывается строка \emph{Counter overflow - }, а затем текущее значение счетчика \emph{cnt} конвертируется в строковое представление и добавляется в конец строчки \emph{s}. После этого вызывается функция \emph{writeline()}, которая копирует значение строчки \emph{s} в стандартный вывод среды модилирования (о чем ей сообщает зарезервированное слово \emph{output}, переданное в качестве первого аргумента), после чего обнуляет эту строчку. К примеру, если значение \emph{MAX\_COUNT} равнялось бы 15, а сигнал \emph{x} имел бы больше 15 передних фронтов, то в консоле во время моделирования появилось бы сообщение 

Counter overflow - 16

\subsection{Файловый ввод/вывод}

Очень часто бывает необходимо промоделировать разрабатываемую схему DUT на больщом объеме входных данных. В таких случаях входные данные храняться в файлах на диске, а моделирующая тестбенч читает их и подает на вход схемы DUT. Если в добавок тестбенч самопроверяющаяся, то и выходные данный схемы DUT необходимо сравнивать с известными опроными результатами, согласованными с входными воздействиями. В этом случае также нельзя обойтись без чтения данных из файлов.

Запись в файл при моделировании используется нечасто, хотя такая возможность есть. 

Итак, для использования файлового ввода/выводы надо использовать туже библиотеку, что и для вывода на экран.

\begin{lstlisting}
use textio.all;
\end{lstlisting}

Объявление и открытие файла просходит с помощью следующей конструкции

\begin{lstlisting}
file logical_name : file_type is mode "file_name";
\end{lstlisting}

Ее можно помещать в начале процесса (\emph{proccess}) до слова \emph{begin}, в начало архитектуры (тоже до \emph{begin}), либо в начале процедур и функций (\emph{procedure, function}). Файл сразу же открывается при объявлении и закрывается при выходе из блока, где был объявлени. Поэтому при объявлении в начале процесса или архитектуры, файл открывается в начале симуляции и закрывается в ее конце, а при вызове из процедуры или функции - будет открываться каждый раз при вызове процедуры и закрываться при ее завершении. 

Параметр объявления \emph{mode} определят направление потока данных и может принимать значения \emph{"in"} - для файла, открытого на чтение, и \emph{"out"} - для файла, открытого на запись. Непосредственная работа с файлами может быть только из блоков кода, где операторы исполняются последовательно (\emph{process, procedure, function}). Для чтения используются слеюдующие функции: \emph{endfile(), readline(), read()} из библиотки textio. Функция \emph{endfile()} проверяет признак конца файла, \emph{readline()} читает из файла целую строку данных и помещает их в переменную типа \emph{line}. А функция \emph{read()} извлекает данные из переменной типа \emph{line} и присваивает их переменным и сигналам, используемым для моделирования. Следующий пример это демонстрирует:

\begin{lstlisting}
READ_FILE: process
  variable VEC_LINE : line;
  variable VEC_VAR : bit_vector(0 to 7);
  file VEC_FILE : text is in "stim.vec";
begin
  while not endfile(VEC_FILE) loop
    readline (VEC_FILE, VEC_LINE);
    read (VEC_LINE, VEC_VAR);
    A_BUS <= VEC_VAR;
    wait for 10 ns;
  end loop;
  wait;
end process READ_FILE;
\end{lstlisting}

В данном случае строка \emph{stim.vec} - это имя текстового файла, откуда будут прочитаны данные. Эта строчка должна содержать либо абсолютное имя файла в операционной файловой системе, либо относительное для того места, откуда запущена симуляция. Для Vivado это обычно что-то похожее на \emph{project\_dir$\backslash$project\_name.sim$\backslash$behav}.

Данные могут быть и записаны в файл, объявленный с \emph{mode = out}, аналогично выводу на консоль, с помощью функций \emph{write()} и \emph{writeline()} через промежуточную переменную типа \emph{line}. Единственное отличие заключается в том, что вместо зарезервированного слова \emph{output}, обозначающего стандартный вывод программы, надо использовать идентификатор файла. 

\begin{lstlisting}
WRITE_FILE: process (CLK)
  variable VEC_LINE : line;
  file VEC_FILE : text is out "results";
begin
  -- strobe OUT_DATA on falling edges 
  -- of CLK and write value out to file
  if CLK='0' then
    write (VEC_LINE, OUT_DATA);
    writeline (VEC_FILE, VEC_LINE);
  end if; 
end process WRITE_FILE;
\end{lstlisting}

Функции \emph{read() и write()} из библиотеки textio определены для типов данных \emph{bit, bit\_vector, boolean, integer, real, string и time}. По стандарту они не совместимы с типами из пакета \emph{std\_logic\_1164}, хотя многие среды моделирования (Vivado в том числе) реализуют подержку типов \emph{std\_logic и std\_logic\_vector}. 


\subsection{Самопроверяющейся тестбенч}

