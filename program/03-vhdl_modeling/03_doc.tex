\chapter{VHDL моделирование углубленно}

\section{Вывод на консоль во время симуляции}

В большинстве языков программирования существует стандартный вывод - механизм, обеспечивающий отображение текстовой информации на мониторе во время работы программы. Язык VHDL также предоставляет такую возможность. Но эта возможность не относится к синтезируемому подмножеству языка - текстовый вывод можно осуществлять только из тестбенча во время моделирования разрабатываемой схемы. В качестве консоли будет выступать текстовое окно вывода среды, в которой происходит моделирование, например Vivado. Хотя среда моделирования предоставляет возможность непосредственно наблюдать значения всех сигналов проекта в окне времянных диаграмм, часто бывает полезно выводит и текстовые сообщения. Эта функциональность обеспечивается стандартной библиотекой textio. Для того чтобы воспользоваться ее функциями необходимо добавить выражение

\begin{lstlisting}
use textio.all;
\end{lstlisting}
непосредственно перед каждой архитектурой, использующей вывод на консоль. На самом деле, с помощью этой библиотеки можно также и осуществлять файловый ввод/вывод, но об этом в следующем параграфе. 

Текстовая информация может быть выдана через переменную (variable) типа line. Вывод на консоль может быть осуществлен только изнутри процесса, где все операторы исполняются последовательно. Для вывода информации в консоль, сначала ее необходимо поместить в переменную типа line, а затем вызвать специальную функцию для собственно выдачи. Следующий пример это иллюстрирует.

\begin{lstlisting}[caption=Вывод в консоль, float]
use textio.all;
architecture behavior of check is
begin
  process (x)
    variable s : line;
    variable cnt : integer:=0;
  begin
    if (x='1' and x'last_value='0') then
      cnt:=cnt+1;
      if (cnt>MAX_COUNT) then
        write(s,"Counter overflow - ");
        write(s,cnt);
        writeline(output,s);
      end if;
    end if;
  end process;
end behavior;
\end{lstlisting}


Функция write используется для добавления текстовой информации в конец переменной типа line, которая инициализируется пустой строчкой. Функция write имеет два аргумента, первый - это имя переменной, куда надо добавить данные, второй - это сами данные. В нашем примере сначала в переменную s записывается строка "Counter overflow - ", а затем текущее значение счетчика cnt конвертируется в строковое представление и добавляется в конец строчки s. После этого вызывается функция writeline, которая копирует значение строчки s в стандартный вывод среды модилирования (о чем ей сообщает зарезервированное слово output, переданное в качестве первого аргумента), после чего обнуляет эту строчку. К примеру, если значение MAX\_COUNT равнялось бы 15, а сигнал x имел бы больше 15 передних фронтов, то в консоле во время моделирования появилось бы сообщение 

Counter overflow - 16

\section{Файловый ввод/вывод}

Очень часто бывает необходимо промоделировать разрабатываемую схему DUT на больщом объеме входных данных. В таких случаях входные данные храняться в файлах на диске, а моделирующая тестбенч читает их и подает на вход схемы DUT. Если в добавок тестбенч самопроверяющаяся, то и выходные данный схемы DUT необходимо сравнивать с известными опроными результатами, согласованными с входными воздействиями. В этом случае также нельзя обойтись без чтения данных из файлов.

Запись в файл при моделировании используется нечасто, хотя такая возможность есть. 

Итак, для использования файлового ввода/выводы надо использовать туже библиотеку, что и для вывода на экран.

\begin{lstlisting}
use textio.all;
\end{lstlisting}

Объявление и открытие файла просходит с помощью следующей конструкции

\begin{lstlisting}
file logical_name : file_type is mode "file_name";
\end{lstlisting}

Ее можно помещать в начале процесса (proccess) до слова begin, в начало архитектуры (тоже до begin), либо в начале процедур и функций (procedure, function). Файл сразу же открывается при объявлении и закрывается при выходе из блока, где был объявлени. Поэтому при объявлении в начале процесса или архитектуры, файл открывается в начале симуляции и закрывается в ее конце, а при вызове из процедуры или функции - будет открываться каждый раз при вызове процедуры и закрываться при ее завершении. 

Параметр объявления mode определят направление потока данных и может принимать значения "in" - для файла, открытого на чтение, и "out" - для файла, открытого на запись. Непосредственная работа с файлами может быть только из блоков кода, где операторы исполняются последовательно (process, procedure, function). Для чтения используются слеюдующие функции: endfile(), readline(), read() из библиотки textio. Функция endfile() проверяет признак конца файла, readline() читает из файла целую строку данных и помещает их в переменную типа line. А функция read() извлекает данные из переменной типа line и присваивает их переменным и сигналам, используемым для моделирования. Следующий пример это демонстрирует:

\begin{lstlisting}
READ_FILE: process
  variable VEC_LINE : line;
  variable VEC_VAR : bit_vector(0 to 7);
  file VEC_FILE : text is in "stim.vec";
begin
  while not endfile(VEC_FILE) loop
    readline (VEC_FILE, VEC_LINE);
    read (VEC_LINE, VEC_VAR);
    A_BUS <= VEC_VAR;
    wait for 10 ns;
  end loop;
  wait;
end process READ_FILE;
\end{lstlisting}

В данном случае строка stim.vec - это имя текстового файла, откуда будут прочитаны данные. Эта строчка должна содержать либо абсолютное имя файла в операционной файловой системе, либо относительное для того места, откуда запущена симуляция. Для Vivado это обычно что-то похожее на project\_dir$\backslash$project\_name.sim$\backslash$behav.

Данные могут быть и записаны в файл, объявленный с mode =  out, аналогично выводу на консоль, с помощью функций write() и writeline() через промежуточную переменную типа line. Единственное отличие заключается в том, что вместо зарезервированного слова "output", обозначающего стандартный вывод программы, надо использовать идентификатор файла. 

\begin{lstlisting}
WRITE_FILE: process (CLK)
  variable VEC_LINE : line;
  file VEC_FILE : text is out "results";
begin
  -- strobe OUT_DATA on falling edges 
  -- of CLK and write value out to file
  if CLK='0' then
    write (VEC_LINE, OUT_DATA);
    writeline (VEC_FILE, VEC_LINE);
  end if; 
end process WRITE_FILE;
\end{lstlisting}

Функции read() и write() из библиотеки textio определены для типов данных bit, bit\_vector, boolean, integer, real, string и time. По стандарту они не совместимы с типами из пакета std\_logic\_1164, хотя многие среды моделирования (Vivado в том числе) реализуют подержку типов std\_logic и std\_logic\_vector. 