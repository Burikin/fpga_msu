Цель данной лабораторной работы - продемонстрировать использование конструкций языка VHDL для реализации самопроверяющейся тестбенчи на примере моделирования генератора следующего элемента последовательности Грея. Однако, сначала рассмотрим саму последовательность Грея, и алгоритм для ее реализации.

\subsubsection{Последовательность или код Грея}
 
Код Грея – система счисления, в которой два соседних значения различаются только в одном разряде. Изначально код Грея предназначался для защиты от ложного срабатывания электромеханических переключателей. Сегодня коды Грея широко используются для упрощения выявления и исправления ошибок в системах связи, а также в формировании сигналов обратной связи в системах управления. Коды Грея часто используются в датчиках-энкодерах (датчиках угла поворота). Также они используются для кодирования номера дорожек в жёстких дисках. Их использование удобно тем, что два соседних значения шкалы сигнала отличаются только в одном разряде. Если с помощью кода Грея перебирать адреса некоторого элемента памяти, то это свойство будет гарантировать отсутствие одновременного переключения нескольких физических линий параллельной шины адреса, что, в свою очередь, предотвращает возникновение шума (или ошибок) в шине адреса в следствии интерференции электромагнитных сигналов.  

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
2-x битный код Грея & 3-x битный код Грея   \\ \hline
\texttt{00} & \texttt{000} \\
\texttt{01} & \texttt{001} \\
\texttt{11} & \texttt{011} \\
\texttt{10} & \texttt{010} \\
 & \texttt{110} \\
 & \texttt{111} \\
 & \texttt{101} \\
 & \texttt{100} \\

\hline
\end{tabular}\par
\caption{Пример кода Грея}
\label{grey_code_table_0}
\end{table}

Рассмотрим алгоритм генерации последовательности Грея.
\begin{enumerate} 
\item Преобразование кода Грея в соответствующий двоичный код.
\item Увеличение на единицу двоичного кода с использованием обычного сумматора.
\item Преобразование двоичного кода обратно в код Грея.
\end{enumerate}

\subsubsection{Преобразование двоичный код $\to$ код Грея}
Обозначим: $g$ – число в представлении Грея, $b$ – число в двоичном представлении, нижним индексом будем обозначать номер бита в представлении. Посмотрим внимательно на таблицу соответствия двоичных кодов и кодов Грея (таблица \ref{grey_code_table_1}). Заметим, что i-й бит в представлении Грея (т.е. $g_{i}$) равен ‘1’, если i-й и (i+1)-й биты в соответствующем двоичном представлении (т.е. $b_{i}$ и $b_{i+1}$) различны, а старший бит всегда одинаков у обоих представлений. (Помним, что самый левый старший бит (most significant bit - MSB) имеет самый большой номер, а самый правый младший бит (least significant bit - LSB) имеет номер 0, т.е. нумерация ведется справа налево.) 

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
Двоичный код       & Код Грея        \\ \hline
\texttt{0000} & \texttt{0000} \\
\texttt{0001} & \texttt{0001} \\
\texttt{0010} & \texttt{0011} \\
\texttt{0011} & \texttt{0010} \\
\texttt{0100} & \texttt{0110} \\
\texttt{0101} & \texttt{0111} \\
\texttt{0110} & \texttt{0101} \\
\texttt{0111} & \texttt{0100} \\
\texttt{1000} & \texttt{1100} \\
\texttt{1001} & \texttt{1101} \\
\texttt{1010} & \texttt{1111} \\
\texttt{1011} & \texttt{1110} \\
\texttt{1100} & \texttt{1010} \\
\texttt{1101} & \texttt{1011} \\
\texttt{1110} & \texttt{1001} \\
\texttt{1111} & \texttt{1000} \\

\hline
\end{tabular}\par
\caption{Соответствие двоичного кода и кода Грея}
\label{grey_code_table_1}
\end{table}


Это наблюдение запишем в виде логического уравнения с использованием оператора «Исключающее ИЛИ» или XOR: 
\begin{equation}
g_{i}=b_{i} \oplus b_{i+1}
\label{eq:g1}
\end{equation}
, при этом для старшего бита следует вместо $b_{i+1}$ подставить $0$. Для 4-битного кода, таким образом, можно записать:
\[g_{3}=b_{3} \oplus 0=b_{3}\]
\[g_{2}=b_{2} \oplus b_{3}\]
\[g_{1}=b_{1} \oplus b_{2}\]
\[g_{0}=b_{0} \oplus b_{1}\]

\subsubsection{Преобразование код Грея $\to$ двоичный код}

Заметим, что если $a \oplus b = c$, то $a = c \oplus b$ (Проверьте это с помощью таблицы истинности). Тогда из уравнения \ref{eq:g1} следует
\begin{equation}
b_{i}=g_{i} \oplus b_{i+1}
\label{eq:g2}
\end{equation}
Уравнение \ref{eq:g2} - это рекурсивная формула, раскроем ее для случая 4-х битных кодов. 
\[b_{3}=g_{3} \oplus 0 = g_{3}\]
\[b_{2}=g_{2} \oplus b_{3} = g_{2} \oplus g_{3}\]
\[b_{1}=g_{1} \oplus b_{2} = g_{1} \oplus g_{2} \oplus g_{3}\]
\[b_{0}=g_{0} \oplus b_{1} = g_{0} \oplus g_{1} \oplus g_{2} \oplus g_{3}\]

\subsubsection{Реализация на VHDL}

Следующий код реализует алгоритм получения следующего элемента последовательности Грея, имея на входе текущий элемент. 

\lstinputlisting[caption=Генератор следующего элемента последовательности Грея, label=lst:g1]{03-vhdl_modeling/lab3-1/src/g_inc.vhd} 

\subsubsection{Подробный анализ тестбенча}

Рассмотрим подробно тестбенч для схемы генератора следующего элемента последовательности Грея (листинг \ref{grey_tb}). Будут рассмотрены только новые конструкции. 

В строчках 3-6 задаются библиотеки и пакеты для ввода/вывода данных в/из файла, вывода текстовых данных на консоль, а также для работы с типом данных \emph{std\_logic}. Строчки 30-33 задают  тип данных \emph{input\_vector\_record}, представляющий собой структуру из двух полей: \emph{integer} и \emph{std\_logic\_vector(3 downto 0)}. В строчке 35 обяъвлен тип данных \emph{input\_vector\_array}, представляющий собой массив из 16 элементов типа \emph{input\_vector\_record}. В строчке 37 объявлена константа типа \emph{input\_vector\_array}, содержащая пронумерованные входные значения для схемы DUT. Данный код может служить примером для создания своих составных типов данных и массивов.  

Строчка 58 задает еще один тип данных \emph{output\_vector\_array} - массив из 16 элементов но на сей раз с элементами типа \emph{std\_logic\_vector(3 downto 0)}. Строчки 60 и 61 объявляют два сигнала типа \emph{output\_vector\_array}, в которые будут сохраняться ожидаемые данные и выходные данные схемы DUT для дальнейшего сравнения. В строчке 62 обявлен массив из 16 элементов типа \emph{boolean}, в который будут заноситься результаты сравнения всех 16 выходных элементов. Наконец, сигнал \emph{results\_ready}, объявленный в строчке 63 является флагом окончания чтения всех выходных данных и начала процесса сравнения результатов. Этот сигнал инициализируется значением 0. 

В строчках 68-71 модуль DUT подключается к сигналам тестбенча. Строчки 75 - 93 - это процесс генерации входных воздействий на схему. В данном случае на вход \emph{g} схемы через каждые 10 ns подаются элементы константного массива \emph{test\_input\_vectors}, а также эти элементы выводятся на консоль. 

Строчки 97-111 задают выходной процесс, в котором выходные значения схемы DUT сохраняются в массиве \emph{real\_output\_vectors}. Обратите внимание, что в данном случае выходной интерфейс схемы тривиален - только шина данных, значение которой считываются просто каждые 10 ns. В реальных схемах, конечно, интерфейсы передаи данных содержать помимо шины данных еще и шины управления передачей. Самые распространенные интерфейсы будут рассмотрены далее в курсе. После того, как все выходные значения DUT были сохранены в массиве \emph{real\_output\_vectors} сигнал \emph{results\_ready} устанавливается в единицу. 

Expected data process, заданный в строчках 114 - 130, просто читает данные из файла \emph{gray\_golden\_output.txt} и сохраняет их в массиве \emph{expected\_output\_vectors}. 

Наконец, в процессе с меткой \emph{compare\_proc} (строчка 135) происходит сравнение данных и вывод результатов на консоль. Начинается процесс с ожидания установления сигнала \emph{results\_ready} в 1 (строчка 141), после чего идет сравнение массивов \emph{real\_output\_vectors} и \emph{expected\_output\_vectors}. На косоль выводятся результаты сравнения для каждого из 16 входных значений, а также глобальный статус моделирования. 


\lstinputlisting[caption=Самопроверяющийся тестбенч для моделирования схемы получения следующего элемента последовательности Грея, label=grey_tb]{03-vhdl_modeling/lab3-1/src/g_inc_tb.vhd}

\subsubsection{Контрольные вопросы} 
\begin{enumerate}
\item Все процессы в тестбенче \ref{grey_tb} содержат оператор wait в конце. Что будет, если удалить этот оператор?
\item Что произойдет, если в строчке 78 изменить ожидание с 100 до 50 ns? 
\end{enumerate}

\subsubsection{Выполнение лабораторной работы} 


\begin{enumerate}
\item Перейти в директорию \emph{03-vhdl\_modeling/lab3-1}
\item Выполнить команду 
\begin{lstlisting}[language = bash]
vivado -mode batch -source create_project.tcl -notrace
\end{lstlisting}
Будет создан Vivado проект в директории \emph{03-vhdl\_modeling/lab3-1/g\_inc}, с уже добавленными исходными файлами из директории \emph{03-vhdl\_modeling/lab3-1/src}.   
\item Открыть созданный Vivado проект.
\item Запустить симуляцию, налюбдать вывод в консоль и вейформы сигналов.
\item Симуляция завершилась с ошибкой. Проанализировать ошибку. Найти в тестбенче ошибку и исправить ее. 
\end{enumerate}