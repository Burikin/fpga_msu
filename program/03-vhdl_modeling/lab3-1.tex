Цель данной лабораторной работы - продемонстрировать использование конструкций языка VHDL для реализации самопроверяющейся тестбенчи на примере моделирования генератора следующего элемента последовательности Грея. Однако, сначала рассмотрим саму последовательность Грея, и алгоритм для ее реализации.

\subsection{Последовательность или код Грея}
 
Код Грея – система счисления, в которой два соседних значения различаются только в одном разряде. Изначально код Грея предназначался для защиты от ложного срабатывания электромеханических переключателей. Сегодня коды Грея широко используются для упрощения выявления и исправления ошибок в системах связи, а также в формировании сигналов обратной связи в системах управления. Коды Грея часто используются в датчиках-энкодерах (датчиках угла поворота). Также они используются для кодирования номера дорожек в жёстких дисках. Их использование удобно тем, что два соседних значения шкалы сигнала отличаются только в одном разряде. Если с помощью кода Грея перебирать адреса некоторого элемента памяти, то это свойство будет гарантировать отсутствие одновременного переключения нескольких физических линий параллельной шины адреса, что, в свою очередь, предотвращает возникновение шума (или ошибок) в шине адреса в следствии интерференции электромагнитных сигналов.  

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
2-x битный код Грея & 3-x битный код Грея   \\ \hline
\texttt{00} & \texttt{000} \\
\texttt{01} & \texttt{001} \\
\texttt{11} & \texttt{011} \\
\texttt{10} & \texttt{010} \\
 & \texttt{110} \\
 & \texttt{111} \\
 & \texttt{101} \\
 & \texttt{100} \\

\hline
\end{tabular}\par
\caption{Пример кода Грея}
\label{grey_code_table_0}
\end{table}

Рассмотрим алгоритм генерации последовательности Грея.
\begin{enumerate} 
\item Преобразование кода Грея в соответствующий двоичный код.
\item Увеличение на единицу двоичного кода с использованием обычного сумматора.
\item Преобразование двоичного кода обратно в код Грея.
\end{enumerate}

\subsubsection{Преобразование двоичный код $\to$ код Грея}
Обозначим: $g$ – число в представлении Грея, $b$ – число в двоичном представлении, нижним индексом будем обозначать номер бита в представлении. Посмотрим внимательно на таблицу соответствия двоичных кодов и кодов Грея (таблица \ref{grey_code_table_1}). Заметим, что i-й бит в представлении Грея (т.е. $g_{i}$) равен ‘1’, если i-й и (i+1)-й биты в соответствующем двоичном представлении (т.е. $b_{i}$ и $b_{i+1}$) различны, а старший бит всегда одинаков у обоих представлений. (Помним, что самый левый старший бит (most significant bit - MSB) имеет самый большой номер, а самый правый младший бит (least significant bit - LSB) имеет номер 0, т.е. нумерация ведется справа налево.) 

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
Двоичный код       & Код Грея        \\ \hline
\texttt{0000} & \texttt{0000} \\
\texttt{0001} & \texttt{0001} \\
\texttt{0010} & \texttt{0011} \\
\texttt{0011} & \texttt{0010} \\
\texttt{0100} & \texttt{0110} \\
\texttt{0101} & \texttt{0111} \\
\texttt{0110} & \texttt{0101} \\
\texttt{0111} & \texttt{0100} \\
\texttt{1000} & \texttt{1100} \\
\texttt{1001} & \texttt{1101} \\
\texttt{1010} & \texttt{1111} \\
\texttt{1011} & \texttt{1110} \\
\texttt{1100} & \texttt{1010} \\
\texttt{1101} & \texttt{1011} \\
\texttt{1110} & \texttt{1001} \\
\texttt{1111} & \texttt{1000} \\

\hline
\end{tabular}\par
\caption{Соответствие двоичного кода и кода Грея}
\label{grey_code_table_1}
\end{table}


Это наблюдение запишем в виде логического уравнения с использованием оператора «Исключающее ИЛИ» или XOR: 
\begin{equation}
g_{i}=b_{i} \oplus b_{i+1}
\label{eq:g1}
\end{equation}
, при этом для старшего бита следует вместо $b_{i+1}$ подставить $0$. Для 4-битного кода, таким образом, можно записать:
\[g_{3}=b_{3} \oplus 0=b_{3}\]
\[g_{2}=b_{2} \oplus b_{3}\]
\[g_{1}=b_{1} \oplus b_{2}\]
\[g_{0}=b_{0} \oplus b_{1}\]

\subsubsection{Преобразование код Грея $\to$ двоичный код}

Заметим, что если $a \oplus b = c$, то $a = c \oplus b$ (Проверьте это с помощью таблицы истинности). Тогда из уравнения \ref{eq:g1} следует
\begin{equation}
b_{i}=g_{i} \oplus b_{i+1}
\label{eq:g2}
\end{equation}
Уравнение \ref{eq:g2} - это рекурсивная формула, раскроем ее для случая 4-х битных кодов. 
\[b_{3}=g_{3} \oplus 0 = g_{3}\]
\[b_{2}=g_{2} \oplus b_{3} = g_{2} \oplus g_{3}\]
\[b_{1}=g_{1} \oplus b_{2} = g_{1} \oplus g_{2} \oplus g_{3}\]
\[b_{0}=g_{0} \oplus b_{1} = g_{0} \oplus g_{1} \oplus g_{2} \oplus g_{3}\]

\subsubsection{Реализация на VHDL}

Следующий код реализует алгоритм получения следующего элемента последовательности Грея, имея на входе текущий элемент. 

\lstinputlisting[caption=Генератор следующего элемента последовательности Грея, label=lst:g1]{03-vhdl_modeling/lab3-1/src/g_inc.vhd} 

\subsection{Подробный анализ тестбенча}



\subsection{Выполнение лабораторной работы} 


\begin{enumerate}
\item Перейти в директорию \emph{03-vhdl\_modeling/lab3-1}
\item Выполнить команду 
\begin{lstlisting}[language = bash]
vivado -mode batch -source create_project.tcl -notrace
\end{lstlisting}
Будет создан Vivado проект в директории \emph{03-vhdl\_modeling/lab3-1/g\_inc}, с уже добавленными исходными файлами из директории \emph{03-vhdl\_modeling/lab3-1/src}.   
\item Выполнить команду 
\end{enumerate}